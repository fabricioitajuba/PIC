CCS PCH C Compiler, Version 4.104, 5967               14-nov-13 08:40

               Filename: D:\Informações\Projetos\GLCD Grafico Trigonometria\GLCD - trigonometria.lst

               ROM used: 3948 bytes (12%)
                         Largest free fragment is 28820
               RAM used: 8 (0%) at main() level
                         93 (5%) worst case
               Stack:    3 locations

*
0000:  GOTO   0D72
.................... //============================================================================// 
.................... //                       PROGRAMA PARA PLOTAR VALORES                         // 
.................... //                            EM UM LCD GRÁFICO                               // 
.................... // ESTAGIÁRIO: Tiago Fernandes da Silva Costa                                 // 
.................... // ORIENTADOR DE ESTÁGIO: Eng. Fabrício de Lima Ribeiro                       // 
.................... //                               08/11/2013                                   // 
.................... //============================================================================// 
....................  
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #fuses HSPLL,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN,NOPBADEN 
.................... #use delay(clock=48000000) 
....................  
.................... #include <GLCD_T.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                           GLCD.C                                //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for using a Hantronix HDM64GS12 with //// 
.................... //// an LED backlight. The HDM64GS12 is 128 pixles across and 64     //// 
.................... //// pixels down. The driver treats the upper left pixel as (0,0).   //// 
.................... ////                                                                 //// 
.................... //// LCD Pin connections:                                            //// 
.................... ////  These can be changed as needed in the defines                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_init(mode)                                                //// 
.................... ////     * Must be called before any other function.                 //// 
.................... ////       - mode can be ON or OFF to turn the LCD on or off         //// 
.................... ////                                                                 //// 
.................... ////  glcd_pixel(x,y,color)                                          //// 
.................... ////     * Sets the pixel to the given color.                        //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_line(x1,y1,x2,y2,color)                                   //// 
.................... ////     * Draws a line from the first point to the second point     //// 
.................... ////       with the given color.                                     //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_rect(x1,y1,x2,y2,fill,color)                              //// 
.................... ////     * Draws a rectangle with upper left point (x1,y1) and lower //// 
.................... ////       right point (x2,y2).                                      //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_bar(x1,y1,x2,y2,width,color)                              //// 
.................... ////     * Draws a bar (wide line) from the first point to the       //// 
.................... ////       second point.                                             //// 
.................... ////       - width is the number of pixels wide                      //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_circle(x,y,radius,fill,color)                             //// 
.................... ////     * Draws a circle with center at (x,y)                       //// 
.................... ////       - fill can be YES or NO                                   //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ////  glcd_text57(x,y,textptr,size,color)                            //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 5 pixels wide and 7 pixels tall.           //// 
.................... ////       - size is an integer that scales the size of the text     //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////     * Note - The given text is character wrapped. If this       //// 
.................... ////       function is used on a different size display, then change //// 
.................... ////       the GLCD_WIDTH define appropriately.                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_text35(x,y,textptr,color)                                 //// 
.................... ////     * Write the null terminated text pointed to by textptr with //// 
.................... ////       the upper left coordinate of the first character at (x,y).//// 
.................... ////       Characters are 3 pixels wide and 5 pixels tall.           //// 
.................... ////       - color is ON or OFF                                      //// 
.................... ////                                                                 //// 
.................... ////  glcd_fillScreen(color)                                         //// 
.................... ////     * Fills the entire LCD with the given color.                //// 
.................... ////       - color can be ON or OFF                                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... //-------------------------------------------------------------------------------// 
.................... // Portado p/ Hardware: Marcelo Campos - Smart Radio - www.SmartRadio.com.br/pic // 
.................... //-------------------------------------------------------------------------------// 
....................  
.................... #define HARDWARE_PIC_EXPERT_2 
.................... //#define HARDWARE PIC_POWER_X17 
....................  
.................... #ifndef GLCD_C 
.................... #define GLCD_C 
....................  
.................... #ifndef GLCD_WIDTH 
.................... #define GLCD_WIDTH 128    // Used for text wrapping by glcd_text57 function 
.................... #endif 
....................  
.................... #define ON  1 
.................... #define OFF 0 
....................  
.................... #define YES 1 
.................... #define NO  0 
....................  
.................... #if defined HARDWARE PIC_POWER_X17 
.................... #error "defined HARDWARE PIC_POWER_X17" 
.................... // PINOS Ligação de acordo com hardware PIC X17 
.................... #ifndef GLCD_DI           // mesmo que RS    
.................... #define GLCD_DI  PIN_E0   // - Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_E1   // - Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_E2   // - Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_C0   // - Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_C2   // - Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_B3   // - Reset 
.................... #endif 
....................  
....................    #define Output_Dados   output_D 
....................    #define Input_Dados      input_D 
....................  
.................... #elif  ( defined HARDWARE_PIC_EXPERT_2 ) 
.................... // COnfigurações placa PIC Expert®            
.................... #ifndef GLCD_DI           // mesmo que RS    
.................... #define GLCD_DI  PIN_E0   // - Data or Instruction input 
.................... #endif 
....................  
.................... #ifndef GLCD_RW 
.................... #define GLCD_RW  PIN_E1   // - Read/Write 
.................... #endif 
....................  
.................... #ifndef GLCD_E 
.................... #define GLCD_E   PIN_E2   // - Enable 
.................... #endif 
....................  
.................... #ifndef GLCD_CS1 
.................... #define GLCD_CS1 PIN_C0   // - Chip Selection 1 
.................... #endif 
....................  
.................... #ifndef GLCD_CS2 
.................... #define GLCD_CS2 PIN_A5   // - Chip Selection 2 
.................... #endif 
....................  
.................... #ifndef GLCD_RST 
.................... #define GLCD_RST PIN_B3   // - Reset 
.................... #endif 
....................  
....................    #define Output_Dados   output_D 
....................    #define Input_Dados      input_D 
.................... #else 
....................    #error "Hardware NÃO DEFINIDO" 
.................... #endif 
....................  
....................  
.................... BYTE glcd_readByte(BYTE chip); 
.................... void glcd_writeByte(BYTE chip, BYTE data); 
.................... void glcd_fillScreen(int1 color); 
....................  
.................... //================================ 
.................... //3x5 Font packed two per definition 
.................... //Original format from http://instruct1.cit.cornell.edu/courses/ee476/video/Video32v2.c 
.................... // - Modified by Steven Cholewiak (www.semifluid.com) 
.................... //    - 08/08/06 - Included punctuation characters 
.................... const int8 TEXT35[95][5]={ 
....................    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b00000000, //SPACE 
....................    0b01000100,   0b01000100,   0b01000100,   0b00000000,   0b01000100, //! 
....................    0b10101010,   0b10101010,   0b00000000,   0b00000000,   0b00000000, //" 
....................    0b10101010,   0b11101110,   0b10101010,   0b11101110,   0b10101010, //# 
....................    0b01100110,   0b11001100,   0b11001100,   0b01100110,   0b11101110, //$ 
....................    0b10101010,   0b00100010,   0b01000100,   0b10001000,   0b10101010, //% 
....................    0b01000100,   0b10101010,   0b01000100,   0b10101010,   0b01100110, //& 
....................    0b01000100,   0b01000100,   0b00000000,   0b00000000,   0b00000000, //' 
....................    0b01000100,   0b10001000,   0b10001000,   0b10001000,   0b01000100, //( 
....................    0b01000100,   0b00100010,   0b00100010,   0b00100010,   0b01000100, //) 
....................    0b00000000,   0b10101010,   0b01000100,   0b10101010,   0b00000000, //* 
....................    0b00000000,   0b01000100,   0b11101110,   0b01000100,   0b00000000, //+ 
....................    0b00000000,   0b00000000,   0b00000000,   0b01000100,   0b10001000, //, 
....................    0b00000000,   0b00000000,   0b11101110,   0b00000000,   0b00000000, //- 
....................    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b01000100, //. 
....................    0b00100010,   0b00100010,   0b01000100,   0b10001000,   0b10001000, /// 
....................    0b11101110,   0b10101010,   0b10101010,   0b10101010,   0b11101110, //0 
....................    0b01000100,   0b11001100,   0b01000100,   0b01000100,   0b11101110, //1 
....................    0b11101110,   0b00100010,   0b11101110,   0b10001000,   0b11101110, //2 
....................    0b11101110,   0b00100010,   0b11101110,   0b00100010,   0b11101110, //3 
....................    0b10101010,   0b10101010,   0b11101110,   0b00100010,   0b00100010, //4 
....................    0b11101110,   0b10001000,   0b11101110,   0b00100010,   0b11101110, //5 
....................    0b11001100,   0b10001000,   0b11101110,   0b10101010,   0b11101110, //6 
....................    0b11101110,   0b00100010,   0b01000100,   0b10001000,   0b10001000, //7 
....................    0b11101110,   0b10101010,   0b11101110,   0b10101010,   0b11101110, //8 
....................    0b11101110,   0b10101010,   0b11101110,   0b00100010,   0b01100110, //9 
....................    0b00000000,   0b01000100,   0b00000000,   0b01000100,   0b00000000, //: 
....................    0b00000000,   0b01000100,   0b00000000,   0b01000100,   0b10001000, //; 
....................    0b00100010,   0b01000100,   0b10001000,   0b01000100,   0b00100010, //< 
....................    0b00000000,   0b11101110,   0b00000000,   0b11101110,   0b00000000, //= 
....................    0b10001000,   0b01000100,   0b00100010,   0b01000100,   0b10001000, //> 
....................    0b11001100,   0b00100010,   0b01100110,   0b00000000,   0b01000100, //? 
....................    0b01000100,   0b10101010,   0b11101110,   0b10001000,   0b01100110, //@ 
....................    0b11101110,   0b10101010,   0b11101110,   0b10101010,   0b10101010, //A 
....................    0b11001100,   0b10101010,   0b11101110,   0b10101010,   0b11001100, //B 
....................    0b11101110,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //C 
....................    0b11001100,   0b10101010,   0b10101010,   0b10101010,   0b11001100, //D 
....................    0b11101110,   0b10001000,   0b11101110,   0b10001000,   0b11101110, //E 
....................    0b11101110,   0b10001000,   0b11101110,   0b10001000,   0b10001000, //F 
....................    0b11101110,   0b10001000,   0b10001000,   0b10101010,   0b11101110, //G 
....................    0b10101010,   0b10101010,   0b11101110,   0b10101010,   0b10101010, //H 
....................    0b11101110,   0b01000100,   0b01000100,   0b01000100,   0b11101110, //I 
....................    0b00100010,   0b00100010,   0b00100010,   0b10101010,   0b11101110, //J 
....................    0b10001000,   0b10101010,   0b11001100,   0b11001100,   0b10101010, //K 
....................    0b10001000,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //L 
....................    0b10101010,   0b11101110,   0b11101110,   0b10101010,   0b10101010, //M 
....................    0b00000000,   0b11001100,   0b10101010,   0b10101010,   0b10101010, //N 
....................    0b01000100,   0b10101010,   0b10101010,   0b10101010,   0b01000100, //O 
....................    0b11101110,   0b10101010,   0b11101110,   0b10001000,   0b10001000, //P 
....................    0b01000100,   0b10101010,   0b10101010,   0b11101110,   0b01100110, //Q 
....................    0b11101110,   0b10101010,   0b11001100,   0b11101110,   0b10101010, //R 
....................    0b11101110,   0b10001000,   0b11101110,   0b00100010,   0b11101110, //S 
....................    0b11101110,   0b01000100,   0b01000100,   0b01000100,   0b01000100, //T 
....................    0b10101010,   0b10101010,   0b10101010,   0b10101010,   0b11101110, //U 
....................    0b10101010,   0b10101010,   0b10101010,   0b10101010,   0b01000100, //V 
....................    0b10101010,   0b10101010,   0b11101110,   0b11101110,   0b10101010, //W 
....................    0b00000000,   0b10101010,   0b01000100,   0b01000100,   0b10101010, //X 
....................    0b10101010,   0b10101010,   0b01000100,   0b01000100,   0b01000100, //Y 
....................    0b11101110,   0b00100010,   0b01000100,   0b10001000,   0b11101110, //Z 
....................    0b11101110,   0b10001000,   0b10001000,   0b10001000,   0b11101110, //[ 
....................    0b10001000,   0b10001000,   0b01000100,   0b00100010,   0b00100010, //\ 
....................    0b11101110,   0b00100010,   0b00100010,   0b00100010,   0b11101110, //] 
....................    0b01000100,   0b10101010,   0b00000000,   0b00000000,   0b00000000, //^ 
....................    0b00000000,   0b00000000,   0b00000000,   0b00000000,   0b11101110, //_ 
....................    0b10001000,   0b01000100,   0b00000000,   0b00000000,   0b00000000, //` 
....................    0b00000000, 0b01000100, 0b10101010, 0b10101010, 0b01100110, //a 
....................    0b10001000, 0b11001100, 0b10101010, 0b10101010, 0b11001100, //b 
....................    0b00000000,   0b01100110, 0b10001000, 0b10001000, 0b01100110, //c 
....................    0b00100010,   0b01100110, 0b10101010, 0b10101010, 0b01100110, //d 
....................    0b00000000, 0b01000100, 0b10101010, 0b11001100, 0b01100110, //e 
....................    0b01100110,   0b01000100, 0b11101110, 0b01000100, 0b01000100, //f 
....................    0b00000000, 0b01000100, 0b10101010, 0b01100110, 0b11001100, //g 
....................    0b10001000, 0b11001100, 0b10101010, 0b10101010, 0b10101010, //h 
....................    0b01000100,   0b00000000, 0b01000100, 0b01000100, 0b01000100, //i 
....................    0b01000100, 0b00000000, 0b01000100, 0b01000100, 0b10001000, //j 
....................    0b10001000,   0b10001000, 0b10101010, 0b11001100, 0b10101010, //k 
....................    0b01000100,   0b01000100, 0b01000100, 0b01000100, 0b01000100, //l 
....................    0b00000000,   0b11101110, 0b11101110, 0b10101010, 0b10101010, //m 
....................    0b00000000,   0b11001100, 0b10101010, 0b10101010, 0b10101010, //n 
....................    0b00000000,   0b01000100, 0b10101010, 0b10101010, 0b01000100, //o 
....................    0b00000000,   0b11001100, 0b10101010, 0b11001100, 0b10001000, //p 
....................    0b00000000,   0b01100110, 0b10101010, 0b01100110, 0b00100010, //q 
....................    0b00000000,   0b10001000, 0b11101110, 0b10001000, 0b10001000, //r 
....................    0b00000000, 0b01100110, 0b11001100, 0b00100010, 0b11001100, //s 
....................    0b01000100,   0b11101110, 0b01000100, 0b01000100, 0b01000100, //t 
....................    0b00000000, 0b10101010, 0b10101010, 0b10101010, 0b01000100, //u 
....................    0b00000000, 0b10101010, 0b10101010, 0b01000100, 0b01000100, //v 
....................    0b00000000,   0b10101010, 0b10101010, 0b11101110, 0b10101010, //w 
....................    0b00000000,   0b10101010, 0b01000100, 0b01000100, 0b10101010, //x 
....................    0b00000000,   0b10101010, 0b10101010, 0b01100110, 0b11001100, //y 
....................    0b00000000, 0b11101110, 0b01100110, 0b11001100, 0b11101110, //z 
....................    0b00100010,   0b01000100,   0b11001100,   0b01000100,   0b00100010, //{ 
....................    0b01000100,   0b01000100,   0b01000100,   0b01000100,   0b01000100, //| 
....................    0b10001000,   0b01000100,   0b01100110,   0b01000100,   0b10001000, //} 
....................    0b00000000,   0b11001100,   0b10101010,   0b00000000,   0b00000000  //~ 
....................    }; 
....................  
.................... const int8 TEXT[51][5] ={0x00, 0x00, 0x00, 0x00, 0x00, // SPACE 
....................                          0x00, 0x00, 0x5F, 0x00, 0x00, // ! 
....................                          0x00, 0x03, 0x00, 0x03, 0x00, // " 
....................                          0x14, 0x3E, 0x14, 0x3E, 0x14, // # 
....................                          0x24, 0x2A, 0x7F, 0x2A, 0x12, // $ 
....................                          0x43, 0x33, 0x08, 0x66, 0x61, // % 
....................                          0x36, 0x49, 0x55, 0x22, 0x50, // & 
....................                          0x00, 0x05, 0x03, 0x00, 0x00, // ' 
....................                          0x00, 0x1C, 0x22, 0x41, 0x00, // ( 
....................                          0x00, 0x41, 0x22, 0x1C, 0x00, // ) 
....................                          0x14, 0x08, 0x3E, 0x08, 0x14, // * 
....................                          0x08, 0x08, 0x3E, 0x08, 0x08, // + 
....................                          0x00, 0x50, 0x30, 0x00, 0x00, // , 
....................                          0x08, 0x08, 0x08, 0x08, 0x08, // - 
....................                          0x00, 0x60, 0x60, 0x00, 0x00, // . 
....................                          0x20, 0x10, 0x08, 0x04, 0x02, // / 
....................                          0x3E, 0x51, 0x49, 0x45, 0x3E, // 0 
....................                          0x04, 0x02, 0x7F, 0x00, 0x00, // 1 
....................                          0x42, 0x61, 0x51, 0x49, 0x46, // 2 
....................                          0x22, 0x41, 0x49, 0x49, 0x36, // 3 
....................                          0x18, 0x14, 0x12, 0x7F, 0x10, // 4 
....................                          0x27, 0x45, 0x45, 0x45, 0x39, // 5 
....................                          0x3E, 0x49, 0x49, 0x49, 0x32, // 6 
....................                          0x01, 0x01, 0x71, 0x09, 0x07, // 7 
....................                          0x36, 0x49, 0x49, 0x49, 0x36, // 8 
....................                          0x26, 0x49, 0x49, 0x49, 0x3E, // 9 
....................                          0x00, 0x36, 0x36, 0x00, 0x00, // : 
....................                          0x00, 0x56, 0x36, 0x00, 0x00, // ; 
....................                          0x08, 0x14, 0x22, 0x41, 0x00, // < 
....................                          0x14, 0x14, 0x14, 0x14, 0x14, // = 
....................                          0x00, 0x41, 0x22, 0x14, 0x08, // > 
....................                          0x02, 0x01, 0x51, 0x09, 0x06, // ? 
....................                          0x3E, 0x41, 0x59, 0x55, 0x5E, // @ 
....................                          0x7E, 0x09, 0x09, 0x09, 0x7E, // A 
....................                          0x7F, 0x49, 0x49, 0x49, 0x36, // B 
....................                          0x3E, 0x41, 0x41, 0x41, 0x22, // C 
....................                          0x7F, 0x41, 0x41, 0x41, 0x3E, // D 
....................                          0x7F, 0x49, 0x49, 0x49, 0x41, // E 
....................                          0x7F, 0x09, 0x09, 0x09, 0x01, // F 
....................                          0x3E, 0x41, 0x41, 0x49, 0x3A, // G 
....................                          0x7F, 0x08, 0x08, 0x08, 0x7F, // H 
....................                          0x00, 0x41, 0x7F, 0x41, 0x00, // I 
....................                          0x30, 0x40, 0x40, 0x40, 0x3F, // J 
....................                          0x7F, 0x08, 0x14, 0x22, 0x41, // K 
....................                          0x7F, 0x40, 0x40, 0x40, 0x40, // L 
....................                          0x7F, 0x02, 0x0C, 0x02, 0x7F, // M 
....................                          0x7F, 0x02, 0x04, 0x08, 0x7F, // N 
....................                          0x3E, 0x41, 0x41, 0x41, 0x3E, // O 
....................                          0x7F, 0x09, 0x09, 0x09, 0x06, // P 
....................                          0x1E, 0x21, 0x21, 0x21, 0x5E, // Q 
....................                          0x7F, 0x09, 0x09, 0x09, 0x76};// R 
....................  
.................... const BYTE TEXT2[44][5]={0x26, 0x49, 0x49, 0x49, 0x32, // S 
....................                          0x01, 0x01, 0x7F, 0x01, 0x01, // T 
....................                          0x3F, 0x40, 0x40, 0x40, 0x3F, // U 
....................                          0x1F, 0x20, 0x40, 0x20, 0x1F, // V 
....................                          0x7F, 0x20, 0x10, 0x20, 0x7F, // W 
....................                          0x41, 0x22, 0x1C, 0x22, 0x41, // X 
....................                          0x07, 0x08, 0x70, 0x08, 0x07, // Y 
....................                          0x61, 0x51, 0x49, 0x45, 0x43, // Z 
....................                          0x00, 0x7F, 0x41, 0x00, 0x00, // [ 
....................                          0x02, 0x04, 0x08, 0x10, 0x20, // \ 
....................                          0x00, 0x00, 0x41, 0x7F, 0x00, // ] 
....................                          0x04, 0x02, 0x01, 0x02, 0x04, // ^ 
....................                          0x40, 0x40, 0x40, 0x40, 0x40, // _ 
....................                          0x00, 0x01, 0x02, 0x04, 0x00, // ` 
....................                          0x20, 0x54, 0x54, 0x54, 0x78, // a 
....................                          0x7F, 0x44, 0x44, 0x44, 0x38, // b 
....................                          0x38, 0x44, 0x44, 0x44, 0x44, // c 
....................                          0x38, 0x44, 0x44, 0x44, 0x7F, // d 
....................                          0x38, 0x54, 0x54, 0x54, 0x18, // e 
....................                          0x04, 0x04, 0x7E, 0x05, 0x05, // f 
....................                          0x08, 0x54, 0x54, 0x54, 0x3C, // g 
....................                          0x7F, 0x08, 0x04, 0x04, 0x78, // h 
....................                          0x00, 0x44, 0x7D, 0x40, 0x00, // i 
....................                          0x20, 0x40, 0x44, 0x3D, 0x00, // j 
....................                          0x7F, 0x10, 0x28, 0x44, 0x00, // k 
....................                          0x00, 0x41, 0x7F, 0x40, 0x00, // l 
....................                          0x7C, 0x04, 0x78, 0x04, 0x78, // m 
....................                          0x7C, 0x08, 0x04, 0x04, 0x78, // n 
....................                          0x38, 0x44, 0x44, 0x44, 0x38, // o 
....................                          0x7C, 0x14, 0x14, 0x14, 0x08, // p 
....................                          0x08, 0x14, 0x14, 0x14, 0x7C, // q 
....................                          0x00, 0x7C, 0x08, 0x04, 0x04, // r 
....................                          0x48, 0x54, 0x54, 0x54, 0x20, // s 
....................                          0x04, 0x04, 0x3F, 0x44, 0x44, // t 
....................                          0x3C, 0x40, 0x40, 0x20, 0x7C, // u 
....................                          0x1C, 0x20, 0x40, 0x20, 0x1C, // v 
....................                          0x3C, 0x40, 0x30, 0x40, 0x3C, // w 
....................                          0x44, 0x28, 0x10, 0x28, 0x44, // x 
....................                          0x0C, 0x50, 0x50, 0x50, 0x3C, // y 
....................                          0x44, 0x64, 0x54, 0x4C, 0x44, // z 
....................                          0x00, 0x08, 0x36, 0x41, 0x41, // { 
....................                          0x00, 0x00, 0x7F, 0x00, 0x00, // | 
....................                          0x41, 0x41, 0x36, 0x08, 0x00, // } 
....................                          0x02, 0x01, 0x02, 0x04, 0x02};// ~ 
....................  
....................  
.................... // Purpose:       Initialize a graphic LCD. This must be called before any 
.................... //                other glcd function is used. 
.................... // Inputs:        The initialization mode 
.................... //                OFF - Turns the LCD off 
.................... //                ON  - Turns the LCD on 
.................... // Date:          5/28/2003 
.................... void glcd_init(int1 mode) 
.................... { 
....................    // Initialze some pins 
....................    output_high(GLCD_RST); 
....................    output_low(GLCD_E); 
*
00B6:  BCF    F93.3
00B8:  BSF    F8A.3
....................    output_low(GLCD_CS1); 
00BA:  BCF    F96.2
00BC:  BCF    F8D.2
....................    output_low(GLCD_CS2); 
00BE:  BCF    F94.0
00C0:  BCF    F8B.0
....................  
00C2:  BCF    F92.5
00C4:  BCF    F89.5
....................    output_low(GLCD_DI);                // Set for instruction 
....................    glcd_writeByte(GLCD_CS1, 0xC0);     // Specify first RAM line at the top 
00C6:  BCF    F96.0
00C8:  BCF    F8D.0
....................    glcd_writeByte(GLCD_CS2, 0xC0);     //   of the screen 
00CA:  MOVLW  10
00CC:  MOVWF  24
00CE:  MOVLW  C0
00D0:  MOVWF  25
00D2:  RCALL  0004
....................    glcd_writeByte(GLCD_CS1, 0x40);     // Set the column address to 0 
00D4:  MOVLW  05
00D6:  MOVWF  24
00D8:  MOVLW  C0
00DA:  MOVWF  25
00DC:  RCALL  0004
....................    glcd_writeByte(GLCD_CS2, 0x40); 
00DE:  MOVLW  10
00E0:  MOVWF  24
00E2:  MOVLW  40
00E4:  MOVWF  25
00E6:  RCALL  0004
....................    glcd_writeByte(GLCD_CS1, 0xB8);     // Set the page address to 0 
00E8:  MOVLW  05
00EA:  MOVWF  24
00EC:  MOVLW  40
00EE:  MOVWF  25
00F0:  RCALL  0004
....................    glcd_writeByte(GLCD_CS2, 0xB8); 
00F2:  MOVLW  10
00F4:  MOVWF  24
00F6:  MOVLW  B8
00F8:  MOVWF  25
00FA:  RCALL  0004
....................    if(mode == ON) 
00FC:  MOVLW  05
00FE:  MOVWF  24
0100:  MOVLW  B8
0102:  MOVWF  25
0104:  RCALL  0004
....................    { 
0106:  DECFSZ 10,W
0108:  BRA    0120
....................       glcd_writeByte(GLCD_CS1, 0x3F);  // Turn the display on 
....................       glcd_writeByte(GLCD_CS2, 0x3F); 
010A:  MOVLW  10
010C:  MOVWF  24
010E:  MOVLW  3F
0110:  MOVWF  25
0112:  RCALL  0004
....................    } 
0114:  MOVLW  05
0116:  MOVWF  24
0118:  MOVLW  3F
011A:  MOVWF  25
011C:  RCALL  0004
....................    else 
....................    { 
011E:  BRA    0134
....................       glcd_writeByte(GLCD_CS1, 0x3E);  // Turn the display off 
....................       glcd_writeByte(GLCD_CS2, 0x3E); 
0120:  MOVLW  10
0122:  MOVWF  24
0124:  MOVLW  3E
0126:  MOVWF  25
0128:  RCALL  0004
....................    } 
012A:  MOVLW  05
012C:  MOVWF  24
012E:  MOVLW  3E
0130:  MOVWF  25
0132:  RCALL  0004
....................  
....................    glcd_fillScreen(OFF);               // Clear the display 
.................... } 
0134:  CLRF   11
0136:  BRA    003A
....................  
0138:  GOTO   0D8E (RETURN)
....................  
.................... // Purpose:       Turn a pixel on a graphic LCD on or off 
.................... // Inputs:        x - the x coordinate of the pixel 
.................... //                y - the y coordinate of the pixel 
.................... //                color - ON or OFF 
.................... // Output:        1 if coordinate out of range, 0 if in range 
.................... void glcd_pixel(int x, int y, int1 color) 
.................... { 
....................    BYTE data; 
*
01E4:  MOVLW  10
01E6:  MOVWF  22
....................    BYTE chip = GLCD_CS1;  // Stores which chip to use on the LCD 
....................  
....................    if(x > 63)  // Check for first or second display area 
....................    { 
01E8:  MOVF   1E,W
01EA:  SUBLW  3F
01EC:  BC    01F6
....................       x -= 64; 
....................       chip = GLCD_CS2; 
01EE:  MOVLW  40
01F0:  SUBWF  1E,F
....................    } 
01F2:  MOVLW  05
01F4:  MOVWF  22
....................  
....................    output_low(GLCD_DI);                                     // Set for instruction 
....................    bit_clear(x,7);                                          // Clear the MSB. Part of an instruction code 
01F6:  BCF    F96.0
01F8:  BCF    F8D.0
....................    bit_set(x,6);                                            // Set bit 6. Also part of an instruction code 
01FA:  BCF    1E.7
....................    glcd_writeByte(chip, x);                                 // Set the horizontal address 
01FC:  BSF    1E.6
....................    glcd_writeByte(chip, (y/8 & 0b10111111) | 0b10111000);   // Set the vertical page address 
01FE:  MOVFF  22,24
0202:  MOVFF  1E,25
0206:  RCALL  0004
....................    output_high(GLCD_DI);                                    // Set for data 
0208:  RRCF   1F,W
020A:  MOVWF  00
020C:  RRCF   00,F
020E:  RRCF   00,F
0210:  MOVLW  1F
0212:  ANDWF  00,F
0214:  MOVF   00,W
0216:  ANDLW  BF
0218:  IORLW  B8
021A:  MOVWF  23
021C:  MOVFF  22,24
0220:  MOVWF  25
0222:  RCALL  0004
....................    data = glcd_readByte(chip); 
0224:  BCF    F96.0
0226:  BSF    F8D.0
....................  
0228:  MOVFF  22,23
022C:  BRA    0186
022E:  MOVFF  01,21
....................    if(color == ON) 
....................       bit_set(data, y%8);        // Turn the pixel on 
0232:  DECFSZ 20,W
0234:  BRA    0254
....................    else                          // or 
0236:  MOVF   1F,W
0238:  ANDLW  07
023A:  MOVWF  23
023C:  MOVLW  01
023E:  MOVWF  00
0240:  MOVF   23,W
0242:  MOVWF  01
0244:  BZ    024E
0246:  BCF    FD8.0
0248:  RLCF   00,F
024A:  DECFSZ 01,F
024C:  BRA    0246
024E:  MOVF   00,W
0250:  IORWF  21,F
....................       bit_clear(data, y%8);      // turn the pixel off 
0252:  BRA    0272
....................    output_low(GLCD_DI);          // Set for instruction 
0254:  MOVF   1F,W
0256:  ANDLW  07
0258:  MOVWF  23
025A:  MOVLW  01
025C:  MOVWF  00
025E:  MOVF   23,W
0260:  MOVWF  01
0262:  BZ    026C
0264:  BCF    FD8.0
0266:  RLCF   00,F
0268:  DECFSZ 01,F
026A:  BRA    0264
026C:  MOVF   00,W
026E:  XORLW  FF
0270:  ANDWF  21,F
....................    glcd_writeByte(chip, x);      // Set the horizontal address 
0272:  BCF    F96.0
0274:  BCF    F8D.0
....................    output_high(GLCD_DI);         // Set for data 
0276:  MOVFF  22,24
027A:  MOVFF  1E,25
027E:  RCALL  0004
....................    glcd_writeByte(chip, data);   // Write the pixel data 
0280:  BCF    F96.0
0282:  BSF    F8D.0
.................... } 
0284:  MOVFF  22,24
0288:  MOVFF  21,25
028C:  RCALL  0004
....................  
028E:  RETLW  00
....................  
.................... // Purpose:       Draw a line on a graphic LCD using Bresenham's 
.................... //                line drawing algorithm 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel() 
.................... void glcd_line(int x1, int y1, int x2, int y2, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, dx, dy; 
....................    signed long P; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
0290:  MOVF   10,W
0292:  SUBWF  12,W
0294:  MOVWF  1E
0296:  MOVF   1E,W
0298:  BTFSS  1E.7
029A:  BRA    02A2
029C:  MOVLW  00
029E:  BSF    FD8.0
02A0:  SUBFWB 1E,W
02A2:  MOVWF  19
....................    x = x1; 
02A4:  MOVF   11,W
02A6:  SUBWF  13,W
02A8:  MOVWF  1E
02AA:  MOVF   1E,W
02AC:  BTFSS  1E.7
02AE:  BRA    02B6
02B0:  MOVLW  00
02B2:  BSF    FD8.0
02B4:  SUBFWB 1E,W
02B6:  MOVWF  1A
....................    y = y1; 
02B8:  MOVFF  10,15
....................  
02BC:  MOVFF  11,16
....................    if(x1 > x2) 
....................       addx = -1; 
02C0:  MOVF   10,W
02C2:  SUBWF  12,W
02C4:  BC    02CC
....................    else 
02C6:  MOVLW  FF
02C8:  MOVWF  17
....................       addx = 1; 
02CA:  BRA    02D0
....................    if(y1 > y2) 
02CC:  MOVLW  01
02CE:  MOVWF  17
....................       addy = -1; 
02D0:  MOVF   11,W
02D2:  SUBWF  13,W
02D4:  BC    02DC
....................    else 
02D6:  MOVLW  FF
02D8:  MOVWF  18
....................       addy = 1; 
02DA:  BRA    02E0
....................  
02DC:  MOVLW  01
02DE:  MOVWF  18
....................    if(dx >= dy) 
....................    { 
02E0:  MOVF   1A,W
02E2:  XORLW  80
02E4:  MOVWF  00
02E6:  MOVF   19,W
02E8:  XORLW  80
02EA:  SUBWF  00,W
02EC:  BZ    02F0
02EE:  BC    037E
....................       P = 2*dy - dx; 
....................  
02F0:  MOVLW  02
02F2:  MOVWF  1F
02F4:  MOVFF  1A,20
02F8:  RCALL  013C
02FA:  MOVF   19,W
02FC:  SUBWF  01,W
02FE:  CLRF   03
0300:  BTFSC  FE8.7
0302:  DECF   03,F
0304:  MOVWF  1B
0306:  MOVFF  03,1C
....................       for(i=0; i<=dx; ++i) 
....................       { 
030A:  CLRF   1D
030C:  BTFSC  19.7
030E:  BRA    037C
0310:  MOVF   1D,W
0312:  SUBWF  19,W
0314:  BNC   037C
....................          glcd_pixel(x, y, color); 
....................  
0316:  MOVFF  15,1E
031A:  MOVFF  16,1F
031E:  MOVFF  14,20
0322:  RCALL  01E4
....................          if(P < 0) 
....................          { 
0324:  BTFSC  1C.7
0326:  BRA    032A
0328:  BRA    0348
....................             P += 2*dy; 
....................             x += addx; 
032A:  MOVLW  02
032C:  MOVWF  1F
032E:  MOVFF  1A,20
0332:  RCALL  013C
0334:  MOVF   01,W
0336:  CLRF   03
0338:  BTFSC  FE8.7
033A:  DECF   03,F
033C:  ADDWF  1B,F
033E:  MOVF   03,W
0340:  ADDWFC 1C,F
....................          } 
0342:  MOVF   17,W
0344:  ADDWF  15,F
....................          else 
....................          { 
0346:  BRA    0378
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
0348:  MOVLW  02
034A:  MOVWF  1F
034C:  MOVFF  1A,20
0350:  RCALL  013C
0352:  MOVFF  01,1E
0356:  MOVLW  02
0358:  MOVWF  1F
035A:  MOVFF  19,20
035E:  RCALL  013C
0360:  MOVF   01,W
0362:  SUBWF  1E,W
0364:  CLRF   03
0366:  BTFSC  FE8.7
0368:  DECF   03,F
036A:  ADDWF  1B,F
036C:  MOVF   03,W
036E:  ADDWFC 1C,F
....................             y += addy; 
0370:  MOVF   17,W
0372:  ADDWF  15,F
....................          } 
0374:  MOVF   18,W
0376:  ADDWF  16,F
....................       } 
....................    } 
0378:  INCF   1D,F
037A:  BRA    030C
....................    else 
....................    { 
037C:  BRA    040A
....................       P = 2*dx - dy; 
....................  
037E:  MOVLW  02
0380:  MOVWF  1F
0382:  MOVFF  19,20
0386:  RCALL  013C
0388:  MOVF   1A,W
038A:  SUBWF  01,W
038C:  CLRF   03
038E:  BTFSC  FE8.7
0390:  DECF   03,F
0392:  MOVWF  1B
0394:  MOVFF  03,1C
....................       for(i=0; i<=dy; ++i) 
....................       { 
0398:  CLRF   1D
039A:  BTFSC  1A.7
039C:  BRA    040A
039E:  MOVF   1D,W
03A0:  SUBWF  1A,W
03A2:  BNC   040A
....................          glcd_pixel(x, y, color); 
....................  
03A4:  MOVFF  15,1E
03A8:  MOVFF  16,1F
03AC:  MOVFF  14,20
03B0:  RCALL  01E4
....................          if(P < 0) 
....................          { 
03B2:  BTFSC  1C.7
03B4:  BRA    03B8
03B6:  BRA    03D6
....................             P += 2*dx; 
....................             y += addy; 
03B8:  MOVLW  02
03BA:  MOVWF  1F
03BC:  MOVFF  19,20
03C0:  RCALL  013C
03C2:  MOVF   01,W
03C4:  CLRF   03
03C6:  BTFSC  FE8.7
03C8:  DECF   03,F
03CA:  ADDWF  1B,F
03CC:  MOVF   03,W
03CE:  ADDWFC 1C,F
....................          } 
03D0:  MOVF   18,W
03D2:  ADDWF  16,F
....................          else 
....................          { 
03D4:  BRA    0406
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
03D6:  MOVLW  02
03D8:  MOVWF  1F
03DA:  MOVFF  19,20
03DE:  RCALL  013C
03E0:  MOVFF  01,1E
03E4:  MOVLW  02
03E6:  MOVWF  1F
03E8:  MOVFF  1A,20
03EC:  RCALL  013C
03EE:  MOVF   01,W
03F0:  SUBWF  1E,W
03F2:  CLRF   03
03F4:  BTFSC  FE8.7
03F6:  DECF   03,F
03F8:  ADDWF  1B,F
03FA:  MOVF   03,W
03FC:  ADDWFC 1C,F
....................             y += addy; 
03FE:  MOVF   17,W
0400:  ADDWF  15,F
....................          } 
0402:  MOVF   18,W
0404:  ADDWF  16,F
....................       } 
....................    } 
0406:  INCF   1D,F
0408:  BRA    039A
.................... } 
....................  
040A:  RETLW  00
....................  
.................... // Purpose:       Draw a rectangle on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                fill  - YES or NO 
.................... //                color - ON or OFF 
.................... // Dependencies:  glcd_pixel(), glcd_line() 
.................... void glcd_rect(int x1, int y1, int x2, int y2, int fill, int1 color) 
.................... { 
....................    if(fill) 
....................    { 
....................       int y, ymax;                          // Find the y min and max 
....................       if(y1 < y2) 
....................       { 
....................          y = y1; 
....................          ymax = y2; 
....................       } 
....................       else 
....................       { 
....................          y = y2; 
....................          ymax = y1; 
....................       } 
....................  
....................       for(; y<=ymax; ++y)                    // Draw lines to fill the rectangle 
....................          glcd_line(x1, y, x2, y, color); 
....................    } 
....................    else 
....................    { 
....................       glcd_line(x1, y1, x2, y1, color);      // Draw the 4 sides 
....................       glcd_line(x1, y2, x2, y2, color); 
....................       glcd_line(x1, y1, x1, y2, color); 
....................       glcd_line(x2, y1, x2, y2, color); 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a bar (wide line) on a graphic LCD 
.................... // Inputs:        (x1, y1) - the start coordinate 
.................... //                (x2, y2) - the end coordinate 
.................... //                width  - The number of pixels wide 
.................... //                color - ON or OFF 
.................... void glcd_bar(int x1, int y1, int x2, int y2, int width, int1 color) 
.................... { 
....................    signed int  x, y, addx, addy, j; 
....................    signed long P, dx, dy, c1, c2; 
....................    int i; 
....................    dx = abs((signed int)(x2 - x1)); 
....................    dy = abs((signed int)(y2 - y1)); 
....................    x = x1; 
....................    y = y1; 
....................    c1 = -dx*x1 - dy*y1; 
....................    c2 = -dx*x2 - dy*y2; 
....................  
....................    if(x1 > x2) 
....................    { 
....................       addx = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addx = 1; 
....................    if(y1 > y2) 
....................    { 
....................       addy = -1; 
....................       c1 = -dx*x2 - dy*y2; 
....................       c2 = -dx*x1 - dy*y1; 
....................    } 
....................    else 
....................       addy = 1; 
....................  
....................    if(dx >= dy) 
....................    { 
....................       P = 2*dy - dx; 
....................  
....................       for(i=0; i<=dx; ++i) 
....................       { 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x, y+j, color); 
....................          } 
....................          if(P < 0) 
....................          { 
....................             P += 2*dy; 
....................             x += addx; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dy - 2*dx; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       P = 2*dx - dy; 
....................  
....................       for(i=0; i<=dy; ++i) 
....................       { 
....................          if(P < 0) 
....................          { 
....................             P += 2*dx; 
....................             y += addy; 
....................          } 
....................          else 
....................          { 
....................             P += 2*dx - 2*dy; 
....................             x += addx; 
....................             y += addy; 
....................          } 
....................          for(j=-(width/2); j<width/2+width%2; ++j) 
....................          { 
....................             if(dx*x+dy*(y+j)+c1 >= 0 && dx*x+dy*(y+j)+c2 <=0) 
....................                glcd_pixel(x+j, y, color); 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Draw a circle on a graphic LCD 
.................... // Inputs:        (x,y) - the center of the circle 
.................... //                radius - the radius of the circle 
.................... //                fill - YES or NO 
.................... //                color - ON or OFF 
.................... void glcd_circle(int x, int y, int radius, int1 fill, int1 color) 
.................... { 
....................    signed int a, b, P; 
....................    a = 0; 
....................    b = radius; 
....................    P = 1 - radius; 
....................  
....................    do 
....................    { 
....................       if(fill) 
....................       { 
....................          glcd_line(x-a, y+b, x+a, y+b, color); 
....................          glcd_line(x-a, y-b, x+a, y-b, color); 
....................          glcd_line(x-b, y+a, x+b, y+a, color); 
....................          glcd_line(x-b, y-a, x+b, y-a, color); 
....................       } 
....................       else 
....................       { 
....................          glcd_pixel(a+x, b+y, color); 
....................          glcd_pixel(b+x, a+y, color); 
....................          glcd_pixel(x-a, b+y, color); 
....................          glcd_pixel(x-b, a+y, color); 
....................          glcd_pixel(b+x, y-a, color); 
....................          glcd_pixel(a+x, y-b, color); 
....................          glcd_pixel(x-a, y-b, color); 
....................          glcd_pixel(x-b, y-a, color); 
....................       } 
....................  
....................       if(P < 0) 
....................          P+= 3 + 2*a++; 
....................       else 
....................          P+= 5 + 2*(a++ - b--); 
....................     } while(a <= b); 
.................... } 
....................  
.................... // Purpose:       Write text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                size - The size of the text: 1 = 5x7, 2 = 10x14, ... 
.................... //                color - ON or OFF 
.................... void glcd_text57(int x, int y, char* textptr, int size, int1 color) 
.................... { 
....................    int i, j, k, l, m;                     // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
....................    { 
....................       if(textptr[i] < 'S') // Checks if the letter is in the first text array 
....................          memcpy(pixelData, TEXT[textptr[i]-' '], 5); 
....................       else if(textptr[i] <= '~') // Check if the letter is in the second array 
....................          memcpy(pixelData, TEXT2[textptr[i]-'S'], 5); 
....................       else 
....................          memcpy(pixelData, TEXT[0], 5);   // Default to space 
....................  
....................       if(x+5*size >= GLCD_WIDTH)          // Performs character wrapping 
....................       { 
....................          x = 0;                           // Set x at far left position 
....................          y += 7*size + 1;                 // Set y at next position down 
....................       } 
....................       for(j=0; j<5; ++j, x+=size)         // Loop through character byte data 
....................       { 
....................          for(k=0; k<7*size; ++k)          // Loop through the vertical pixels 
....................          { 
....................             if(bit_test(pixelData[j], k)) // Check if the pixel should be set 
....................             { 
....................                for(l=0; l<size; ++l)      // The next two loops change the 
....................                {                          // character's size 
....................                   for(m=0; m<size; ++m) 
....................                   { 
....................                      glcd_pixel(x+m, y+k*size+l, color); // Draws the pixel 
....................                   } 
....................                } 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Purpose:       Write small text on a graphic LCD 
.................... // Inputs:        (x,y) - The upper left coordinate of the first letter 
.................... //                textptr - A pointer to an array of text to display 
.................... //                color - ON or OFF 
....................  
.................... //char characterSet[] = " !#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"; 
.................... void glcd_text35(int8 x, int8 y, char* textptr, int1 color) 
.................... { 
....................    int i, j, k;                           // Loop counters 
....................    BYTE pixelData[5];                     // Stores character data 
....................  
....................    for(i=0; textptr[i] != '\0'; ++i, ++x) // Loop through the passed string 
....................    { 
....................       if((textptr[i] >= ' ') && (textptr[i] <= '~')) 
....................          memcpy(pixelData, TEXT35[textptr[i]-' '], 5); 
....................       else 
....................          memcpy(pixelData, TEXT35[0], 5); // Default to space 
....................  
....................       if(x+3 >= GLCD_WIDTH)          // Performs character wrapping 
....................       { 
....................          x = 0;                           // Set x at far left position 
....................          y += 5 + 1;                      // Set y at next position down 
....................       } 
....................       for(j=3; j>0; j--, x++)             // Loop through character byte data 
....................       { 
....................          for(k=0; k<5; k++)               // Loop through the vertical pixels 
....................          { 
....................             if(bit_test(pixelData[k], j)) // Check if the pixel should be set 
....................             { 
....................                glcd_pixel(x, y+k, color); // Draws the pixel 
....................             } 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Purpose:       Fill the LCD screen with the passed in color. 
.................... //                Works much faster than drawing a rectangle to fill the screen. 
.................... // Inputs:        ON - turn all the pixels on 
.................... //                OFF - turn all the pixels off 
.................... // Dependencies:  glcd_writeByte() 
.................... void glcd_fillScreen(int1 color) 
.................... { 
....................    int i, j; 
....................  
....................    // Loop through the vertical pages 
....................    for(i = 0; i < 8; ++i) 
....................    { 
*
003A:  CLRF   12
003C:  MOVF   12,W
003E:  SUBLW  07
0040:  BNC   00B2
....................       output_low(GLCD_DI);                      // Set for instruction 
....................       glcd_writeByte(GLCD_CS1, 0b01000000);     // Set horizontal address to 0 
0042:  BCF    F96.0
0044:  BCF    F8D.0
....................       glcd_writeByte(GLCD_CS2, 0b01000000); 
0046:  MOVLW  10
0048:  MOVWF  24
004A:  MOVLW  40
004C:  MOVWF  25
004E:  RCALL  0004
....................       glcd_writeByte(GLCD_CS1, i | 0b10111000); // Set page address 
0050:  MOVLW  05
0052:  MOVWF  24
0054:  MOVLW  40
0056:  MOVWF  25
0058:  RCALL  0004
....................       glcd_writeByte(GLCD_CS2, i | 0b10111000); 
005A:  MOVF   12,W
005C:  IORLW  B8
005E:  MOVWF  14
0060:  MOVLW  10
0062:  MOVWF  24
0064:  MOVFF  14,25
0068:  RCALL  0004
....................       output_high(GLCD_DI);                     // Set for data 
006A:  MOVF   12,W
006C:  IORLW  B8
006E:  MOVWF  14
0070:  MOVLW  05
0072:  MOVWF  24
0074:  MOVFF  14,25
0078:  RCALL  0004
....................  
007A:  BCF    F96.0
007C:  BSF    F8D.0
....................       // Loop through the horizontal sections 
....................       for(j = 0; j < 64; ++j) 
....................       { 
007E:  CLRF   13
0080:  MOVF   13,W
0082:  SUBLW  3F
0084:  BNC   00AE
....................          glcd_writeByte(GLCD_CS1, 0xFF*color);  // Turn pixels on or off 
....................          glcd_writeByte(GLCD_CS2, 0xFF*color);  // Turn pixels on or off 
0086:  MOVF   11,W
0088:  MULLW  FF
008A:  MOVFF  FF3,14
008E:  MOVLW  10
0090:  MOVWF  24
0092:  MOVFF  14,25
0096:  RCALL  0004
....................       } 
0098:  MOVF   11,W
009A:  MULLW  FF
009C:  MOVFF  FF3,14
00A0:  MOVLW  05
00A2:  MOVWF  24
00A4:  MOVFF  14,25
00A8:  RCALL  0004
....................    } 
00AA:  INCF   13,F
00AC:  BRA    0080
.................... } 
00AE:  INCF   12,F
00B0:  BRA    003C
....................  
00B2:  GOTO   0138 (RETURN)
.................... // Purpose:       Write a byte of data to the specified chip 
.................... // Inputs:        chipSelect - which chip to write the data to 
.................... //                data - the byte of data to write 
....................  
.................... void glcd_writeByte(char chip, BYTE data) 
.................... { 
....................    if(chip == GLCD_CS1)       // Choose which chip to write to 
....................       output_high(GLCD_CS1); 
*
0004:  MOVF   24,W
0006:  SUBLW  10
0008:  BNZ   0010
....................    else 
000A:  BCF    F94.0
000C:  BSF    F8B.0
....................       output_high(GLCD_CS2); 
000E:  BRA    0014
....................  
0010:  BCF    F92.5
0012:  BSF    F89.5
....................    output_low(GLCD_RW);       // Set for writing 
....................    Output_Dados(data);            // Put the data on the port 
0014:  BCF    F96.1
0016:  BCF    F8D.1
....................    output_high(GLCD_E);       // Pulse the enable pin 
0018:  CLRF   F95
001A:  MOVFF  25,F8C
....................    delay_us(10); 
001E:  BCF    F96.2
0020:  BSF    F8D.2
....................    output_low(GLCD_E); 
0022:  MOVLW  27
0024:  MOVWF  00
0026:  DECFSZ 00,F
0028:  BRA    0026
002A:  BRA    002C
....................  
002C:  BCF    F96.2
002E:  BCF    F8D.2
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
0030:  BCF    F94.0
0032:  BCF    F8B.0
.................... } 
0034:  BCF    F92.5
0036:  BCF    F89.5
....................  
0038:  RETLW  00
....................  
.................... // Purpose:       Reads a byte of data from the specified chip 
.................... // Ouputs:        A byte of data read from the chip 
.................... BYTE glcd_readByte(BYTE chip) 
.................... { 
....................    BYTE data;                 // Stores the data read from the LCD 
....................    if(chip == GLCD_CS1)       // Choose which chip to read from 
....................       output_high(GLCD_CS1); 
*
0186:  MOVF   23,W
0188:  SUBLW  10
018A:  BNZ   0192
....................    else 
018C:  BCF    F94.0
018E:  BSF    F8B.0
....................       output_high(GLCD_CS2); 
0190:  BRA    0196
....................  
0192:  BCF    F92.5
0194:  BSF    F89.5
....................    Input_Dados();                 // Set port d to input 
....................    output_high(GLCD_RW);      // Set for reading 
0196:  MOVLW  FF
0198:  MOVWF  F95
....................    output_high(GLCD_E);       // Pulse the enable pin 
019A:  BCF    F96.1
019C:  BSF    F8D.1
....................    delay_us(10); 
019E:  BCF    F96.2
01A0:  BSF    F8D.2
....................    output_low(GLCD_E); 
01A2:  MOVLW  27
01A4:  MOVWF  00
01A6:  DECFSZ 00,F
01A8:  BRA    01A6
01AA:  BRA    01AC
....................    delay_us(10); 
01AC:  BCF    F96.2
01AE:  BCF    F8D.2
....................    output_high(GLCD_E);       // Pulse the enable pin 
01B0:  MOVLW  27
01B2:  MOVWF  00
01B4:  DECFSZ 00,F
01B6:  BRA    01B4
01B8:  BRA    01BA
....................    delay_us(10); 
01BA:  BCF    F96.2
01BC:  BSF    F8D.2
....................    data = Input_Dados();          // Get the data from the display's output register 
01BE:  MOVLW  27
01C0:  MOVWF  00
01C2:  DECFSZ 00,F
01C4:  BRA    01C2
01C6:  BRA    01C8
....................    output_low(GLCD_E); 
01C8:  MOVLW  FF
01CA:  MOVWF  F95
01CC:  MOVFF  F83,24
....................  
01D0:  BCF    F96.2
01D2:  BCF    F8D.2
....................    output_low(GLCD_CS1);      // Reset the chip select lines 
....................    output_low(GLCD_CS2); 
01D4:  BCF    F94.0
01D6:  BCF    F8B.0
....................    return data;               // Return the read data 
01D8:  BCF    F92.5
01DA:  BCF    F89.5
.................... } 
01DC:  MOVFF  24,01
....................  
01E0:  GOTO   022E (RETURN)
.................... #endif 
....................  
....................  
.................... #include <MATH.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float32)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float32)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float48)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float48)l); 
....................   res = 32768.0*(float32)l; 
....................   res += (float48)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float48)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................   res = (float64)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    { 
....................   l = (unsigned int16)(y/32768.0); 
....................       y = 32768.0*(y/32768.0 - (float64)l); 
....................   res = 32768.0*(float64)l; 
....................   res += (float64)(unsigned int16)y; 
....................  } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float64)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y/LN2 - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y/LN2 - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x/LN2); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y/LN2 - (float64)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................    bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................     
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................    
....................       if(bit_test(data2,7)) 
....................          bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................       res = res*y2 + pl[2]; 
....................       res = res*y2 + pl[3]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + ql[2]; 
....................       r = r*y2 + ql[3]; 
....................  
....................       res = y*res/r; 
....................  
....................     data1 = *(((unsigned int8 *)(&x)+5)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+4)); 
....................     if(bit_test (data2,7)) 
....................        bit_set(data1,0); 
....................       
....................     n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................          r = -(float48)-n; 
....................       else 
....................          r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float32 const pl_64[4] = {0.45145214, -9.0558803, 26.940971, -19.860189}; 
.................... float32 const ql_64[4] = {1.0000000,  -8.1354259, 16.780517, -9.9300943}; 
.................... #endif 
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................       bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r/LN10; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    BYTE *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(BYTE)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................     bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................     bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................    bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................      bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #define TWOBYPI          0.6366197723675813 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
*
09C8:  CLRF   2B
09CA:  CLRF   2A
09CC:  CLRF   29
09CE:  MOVLW  7F
09D0:  MOVWF  28
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
09D2:  MOVLW  7E
09D4:  MOVWF  32
09D6:  MOVLW  80
09D8:  MOVWF  33
09DA:  CLRF   34
09DC:  CLRF   35
09DE:  MOVLW  7A
09E0:  MOVWF  36
09E2:  MOVLW  2A
09E4:  MOVWF  37
09E6:  MOVLW  AA
09E8:  MOVWF  38
09EA:  MOVLW  AB
09EC:  MOVWF  39
09EE:  MOVLW  75
09F0:  MOVWF  3A
09F2:  MOVLW  B6
09F4:  MOVWF  3B
09F6:  MOVLW  0B
09F8:  MOVWF  3C
09FA:  MOVLW  61
09FC:  MOVWF  3D
09FE:  MOVLW  6F
0A00:  MOVWF  3E
0A02:  MOVLW  50
0A04:  MOVWF  3F
0A06:  MOVLW  0D
0A08:  MOVWF  40
0A0A:  MOVLW  01
0A0C:  MOVWF  41
0A0E:  MOVLW  69
0A10:  MOVWF  42
0A12:  MOVLW  93
0A14:  MOVWF  43
0A16:  MOVLW  F2
0A18:  MOVWF  44
0A1A:  MOVLW  7E
0A1C:  MOVWF  45
0A1E:  MOVLW  62
0A20:  MOVWF  46
0A22:  MOVLW  0F
0A24:  MOVWF  47
0A26:  MOVLW  76
0A28:  MOVWF  48
0A2A:  MOVLW  AE
0A2C:  MOVWF  49
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
0A2E:  MOVFF  1F,4D
0A32:  MOVFF  1E,4C
0A36:  MOVFF  1D,4B
0A3A:  MOVFF  1C,4A
0A3E:  CLRF   51
0A40:  CLRF   50
0A42:  CLRF   4F
0A44:  CLRF   4E
0A46:  BRA    07BE
0A48:  BNC   0A50
0A4A:  MOVF   1D,W
0A4C:  XORLW  80
0A4E:  MOVWF  1D
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
0A50:  MOVFF  1F,4D
0A54:  MOVFF  1E,4C
0A58:  MOVFF  1D,4B
0A5C:  MOVFF  1C,4A
0A60:  MOVLW  DB
0A62:  MOVWF  51
0A64:  MOVLW  0F
0A66:  MOVWF  50
0A68:  MOVLW  49
0A6A:  MOVWF  4F
0A6C:  MOVLW  7F
0A6E:  MOVWF  4E
0A70:  RCALL  0836
0A72:  MOVFF  03,4D
0A76:  MOVFF  02,4C
0A7A:  MOVFF  01,4B
0A7E:  MOVFF  00,4A
0A82:  RCALL  0990
0A84:  MOVFF  01,2C
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
0A88:  MOVFF  1F,4D
0A8C:  MOVFF  1E,4C
0A90:  MOVFF  1D,4B
0A94:  MOVFF  1C,4A
0A98:  MOVLW  DB
0A9A:  MOVWF  51
0A9C:  MOVLW  0F
0A9E:  MOVWF  50
0AA0:  MOVLW  49
0AA2:  MOVWF  4F
0AA4:  MOVLW  7F
0AA6:  MOVWF  4E
0AA8:  RCALL  0836
0AAA:  MOVFF  00,4A
0AAE:  MOVFF  01,4B
0AB2:  MOVFF  02,4C
0AB6:  MOVFF  03,4D
0ABA:  CLRF   4F
0ABC:  MOVFF  2C,4E
0AC0:  RCALL  042C
0AC2:  BSF    FD8.1
0AC4:  MOVFF  4D,51
0AC8:  MOVFF  4C,50
0ACC:  MOVFF  4B,4F
0AD0:  MOVFF  4A,4E
0AD4:  MOVFF  03,55
0AD8:  MOVFF  02,54
0ADC:  MOVFF  01,53
0AE0:  MOVFF  00,52
0AE4:  RCALL  0554
0AE6:  MOVFF  03,31
0AEA:  MOVFF  02,30
0AEE:  MOVFF  01,2F
0AF2:  MOVFF  00,2E
....................    quad = quad % 4;                    // quadrant (0 to 3) 
0AF6:  MOVLW  03
0AF8:  ANDWF  2C,F
....................  
....................    if (quad == 0 || quad == 2) 
0AFA:  MOVF   2C,F
0AFC:  BZ    0B04
0AFE:  MOVF   2C,W
0B00:  SUBLW  02
0B02:  BNZ   0B38
....................       t = frac * PI_DIV_BY_TWO; 
0B04:  MOVFF  31,51
0B08:  MOVFF  30,50
0B0C:  MOVFF  2F,4F
0B10:  MOVFF  2E,4E
0B14:  MOVLW  DB
0B16:  MOVWF  55
0B18:  MOVLW  0F
0B1A:  MOVWF  54
0B1C:  MOVLW  49
0B1E:  MOVWF  53
0B20:  MOVLW  7F
0B22:  MOVWF  52
0B24:  RCALL  0462
0B26:  MOVFF  03,27
0B2A:  MOVFF  02,26
0B2E:  MOVFF  01,25
0B32:  MOVFF  00,24
....................    else if (quad == 1) 
0B36:  BRA    0BFE
0B38:  DECFSZ 2C,W
0B3A:  BRA    0B9E
....................       t = (1-frac) * PI_DIV_BY_TWO; 
0B3C:  BSF    FD8.1
0B3E:  CLRF   51
0B40:  CLRF   50
0B42:  CLRF   4F
0B44:  MOVLW  7F
0B46:  MOVWF  4E
0B48:  MOVFF  31,55
0B4C:  MOVFF  30,54
0B50:  MOVFF  2F,53
0B54:  MOVFF  2E,52
0B58:  RCALL  0554
0B5A:  MOVFF  00,4A
0B5E:  MOVFF  01,4B
0B62:  MOVFF  02,4C
0B66:  MOVFF  03,4D
0B6A:  MOVFF  03,51
0B6E:  MOVFF  02,50
0B72:  MOVFF  01,4F
0B76:  MOVFF  00,4E
0B7A:  MOVLW  DB
0B7C:  MOVWF  55
0B7E:  MOVLW  0F
0B80:  MOVWF  54
0B82:  MOVLW  49
0B84:  MOVWF  53
0B86:  MOVLW  7F
0B88:  MOVWF  52
0B8A:  RCALL  0462
0B8C:  MOVFF  03,27
0B90:  MOVFF  02,26
0B94:  MOVFF  01,25
0B98:  MOVFF  00,24
....................    else // should be 3 
0B9C:  BRA    0BFE
....................       t = (frac-1) * PI_DIV_BY_TWO; 
0B9E:  BSF    FD8.1
0BA0:  MOVFF  31,51
0BA4:  MOVFF  30,50
0BA8:  MOVFF  2F,4F
0BAC:  MOVFF  2E,4E
0BB0:  CLRF   55
0BB2:  CLRF   54
0BB4:  CLRF   53
0BB6:  MOVLW  7F
0BB8:  MOVWF  52
0BBA:  RCALL  0554
0BBC:  MOVFF  00,4A
0BC0:  MOVFF  01,4B
0BC4:  MOVFF  02,4C
0BC8:  MOVFF  03,4D
0BCC:  MOVFF  03,51
0BD0:  MOVFF  02,50
0BD4:  MOVFF  01,4F
0BD8:  MOVFF  00,4E
0BDC:  MOVLW  DB
0BDE:  MOVWF  55
0BE0:  MOVLW  0F
0BE2:  MOVWF  54
0BE4:  MOVLW  49
0BE6:  MOVWF  53
0BE8:  MOVLW  7F
0BEA:  MOVWF  52
0BEC:  RCALL  0462
0BEE:  MOVFF  03,27
0BF2:  MOVFF  02,26
0BF6:  MOVFF  01,25
0BFA:  MOVFF  00,24
....................  
....................    y = 1.0; 
0BFE:  CLRF   23
0C00:  CLRF   22
0C02:  CLRF   21
0C04:  MOVLW  7F
0C06:  MOVWF  20
....................    t = t * t; 
0C08:  MOVFF  27,51
0C0C:  MOVFF  26,50
0C10:  MOVFF  25,4F
0C14:  MOVFF  24,4E
0C18:  MOVFF  27,55
0C1C:  MOVFF  26,54
0C20:  MOVFF  25,53
0C24:  MOVFF  24,52
0C28:  RCALL  0462
0C2A:  MOVFF  03,27
0C2E:  MOVFF  02,26
0C32:  MOVFF  01,25
0C36:  MOVFF  00,24
....................    for (i = 0; i <= 5; i++) 
0C3A:  CLRF   2D
0C3C:  MOVF   2D,W
0C3E:  SUBLW  05
0C40:  BNC   0D04
....................    { 
....................       t2 = t2 * t; 
0C42:  MOVFF  2B,51
0C46:  MOVFF  2A,50
0C4A:  MOVFF  29,4F
0C4E:  MOVFF  28,4E
0C52:  MOVFF  27,55
0C56:  MOVFF  26,54
0C5A:  MOVFF  25,53
0C5E:  MOVFF  24,52
0C62:  CALL   0462
0C66:  MOVFF  03,2B
0C6A:  MOVFF  02,2A
0C6E:  MOVFF  01,29
0C72:  MOVFF  00,28
....................       y = y + p[i] * t2; 
0C76:  MOVF   2D,W
0C78:  MULLW  04
0C7A:  MOVF   FF3,W
0C7C:  CLRF   03
0C7E:  ADDLW  32
0C80:  MOVWF  FE9
0C82:  MOVLW  00
0C84:  ADDWFC 03,W
0C86:  MOVWF  FEA
0C88:  MOVFF  FEF,4A
0C8C:  MOVFF  FEC,4B
0C90:  MOVFF  FEC,4C
0C94:  MOVFF  FEC,4D
0C98:  MOVFF  4D,51
0C9C:  MOVFF  4C,50
0CA0:  MOVFF  4B,4F
0CA4:  MOVFF  4A,4E
0CA8:  MOVFF  2B,55
0CAC:  MOVFF  2A,54
0CB0:  MOVFF  29,53
0CB4:  MOVFF  28,52
0CB8:  CALL   0462
0CBC:  MOVFF  FEA,4B
0CC0:  MOVFF  FE9,4A
0CC4:  BCF    FD8.1
0CC6:  MOVFF  23,51
0CCA:  MOVFF  22,50
0CCE:  MOVFF  21,4F
0CD2:  MOVFF  20,4E
0CD6:  MOVFF  03,55
0CDA:  MOVFF  02,54
0CDE:  MOVFF  01,53
0CE2:  MOVFF  00,52
0CE6:  RCALL  0554
0CE8:  MOVFF  4B,FEA
0CEC:  MOVFF  4A,FE9
0CF0:  MOVFF  03,23
0CF4:  MOVFF  02,22
0CF8:  MOVFF  01,21
0CFC:  MOVFF  00,20
....................    } 
0D00:  INCF   2D,F
0D02:  BRA    0C3C
....................  
....................    if (quad == 2 || quad == 1) 
0D04:  MOVF   2C,W
0D06:  SUBLW  02
0D08:  BZ    0D0E
0D0A:  DECFSZ 2C,W
0D0C:  BRA    0D14
....................       y = -y;  // correct sign 
0D0E:  MOVF   21,W
0D10:  XORLW  80
0D12:  MOVWF  21
....................  
....................    return (y); 
0D14:  MOVFF  20,00
0D18:  MOVFF  21,01
0D1C:  MOVFF  22,02
0D20:  MOVFF  23,03
.................... } 
0D24:  GOTO   0D6E (RETURN)
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float48 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x / PI_DIV_BY_TWO);    // quadrant 
....................    frac = (x / PI_DIV_BY_TWO) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
0D28:  BSF    FD8.1
0D2A:  MOVFF  17,51
0D2E:  MOVFF  16,50
0D32:  MOVFF  15,4F
0D36:  MOVFF  14,4E
0D3A:  MOVLW  DB
0D3C:  MOVWF  55
0D3E:  MOVLW  0F
0D40:  MOVWF  54
0D42:  MOVLW  49
0D44:  MOVWF  53
0D46:  MOVLW  7F
0D48:  MOVWF  52
0D4A:  RCALL  0554
0D4C:  MOVFF  00,18
0D50:  MOVFF  01,19
0D54:  MOVFF  02,1A
0D58:  MOVFF  03,1B
0D5C:  MOVFF  03,1F
0D60:  MOVFF  02,1E
0D64:  MOVFF  01,1D
0D68:  MOVFF  00,1C
0D6C:  BRA    09C8
.................... } 
0D6E:  GOTO   0E48 (RETURN)
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)/2.0); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))/2); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)/LOG2)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... void main () 
.................... { 
0D72:  CLRF   FF8
0D74:  BCF    FD0.7
0D76:  CLRF   FEA
0D78:  CLRF   FE9
0D7A:  MOVF   FC1,W
0D7C:  ANDLW  C0
0D7E:  IORLW  0F
0D80:  MOVWF  FC1
0D82:  MOVLW  07
0D84:  MOVWF  FB4
....................    glcd_init(ON); 
0D86:  MOVLW  01
0D88:  MOVWF  10
0D8A:  GOTO   00B6
....................  
....................    char n; 
....................    int16 i; 
....................    float x, y; 
....................     
....................    glcd_line(0,31,127,31,ON); 
0D8E:  CLRF   10
0D90:  MOVLW  1F
0D92:  MOVWF  11
0D94:  MOVLW  7F
0D96:  MOVWF  12
0D98:  MOVLW  1F
0D9A:  MOVWF  13
0D9C:  MOVLW  01
0D9E:  MOVWF  14
0DA0:  CALL   0290
....................    glcd_line(63,0,63,63,ON); 
0DA4:  MOVLW  3F
0DA6:  MOVWF  10
0DA8:  CLRF   11
0DAA:  MOVWF  12
0DAC:  MOVWF  13
0DAE:  MOVLW  01
0DB0:  MOVWF  14
0DB2:  CALL   0290
....................     
....................    n=1; 
0DB6:  MOVLW  01
0DB8:  MOVWF  05
....................     
....................    for(i=0; i<(360*n); i++) 
0DBA:  CLRF   07
0DBC:  CLRF   06
0DBE:  MOVLW  01
0DC0:  MOVWF  11
0DC2:  MOVLW  68
0DC4:  MOVWF  10
0DC6:  CLRF   13
0DC8:  MOVFF  05,12
0DCC:  GOTO   040C
0DD0:  MOVFF  02,03
0DD4:  MOVF   07,W
0DD6:  SUBWF  02,W
0DD8:  BTFSS  FD8.0
0DDA:  BRA    0F68
0DDC:  BNZ   0DE6
0DDE:  MOVF   01,W
0DE0:  SUBWF  06,W
0DE2:  BTFSC  FD8.0
0DE4:  BRA    0F68
....................    { 
....................       x=(pi/180)*i; 
0DE6:  MOVFF  07,4F
0DEA:  MOVFF  06,4E
0DEE:  CALL   042C
0DF2:  MOVLW  35
0DF4:  MOVWF  51
0DF6:  MOVLW  FA
0DF8:  MOVWF  50
0DFA:  MOVLW  0E
0DFC:  MOVWF  4F
0DFE:  MOVLW  79
0E00:  MOVWF  4E
0E02:  MOVFF  03,55
0E06:  MOVFF  02,54
0E0A:  MOVFF  01,53
0E0E:  MOVFF  00,52
0E12:  CALL   0462
0E16:  MOVFF  03,0B
0E1A:  MOVFF  02,0A
0E1E:  MOVFF  01,09
0E22:  MOVFF  00,08
....................       y=31.5+32*sin(-x); 
0E26:  MOVFF  08,10
0E2A:  MOVF   09,W
0E2C:  XORLW  80
0E2E:  MOVWF  11
0E30:  MOVFF  0A,12
0E34:  MOVFF  0B,13
0E38:  MOVFF  0B,17
0E3C:  MOVFF  0A,16
0E40:  MOVWF  15
0E42:  MOVFF  08,14
0E46:  BRA    0D28
0E48:  CLRF   51
0E4A:  CLRF   50
0E4C:  CLRF   4F
0E4E:  MOVLW  84
0E50:  MOVWF  4E
0E52:  MOVFF  03,55
0E56:  MOVFF  02,54
0E5A:  MOVFF  01,53
0E5E:  MOVFF  00,52
0E62:  CALL   0462
0E66:  MOVFF  FEA,11
0E6A:  MOVFF  FE9,10
0E6E:  BCF    FD8.1
0E70:  CLRF   51
0E72:  CLRF   50
0E74:  MOVLW  7C
0E76:  MOVWF  4F
0E78:  MOVLW  83
0E7A:  MOVWF  4E
0E7C:  MOVFF  03,55
0E80:  MOVFF  02,54
0E84:  MOVFF  01,53
0E88:  MOVFF  00,52
0E8C:  CALL   0554
0E90:  MOVFF  11,FEA
0E94:  MOVFF  10,FE9
0E98:  MOVFF  03,0F
0E9C:  MOVFF  02,0E
0EA0:  MOVFF  01,0D
0EA4:  MOVFF  00,0C
....................       x=(0.355*i)/n; 
0EA8:  MOVFF  07,4F
0EAC:  MOVFF  06,4E
0EB0:  CALL   042C
0EB4:  MOVLW  8F
0EB6:  MOVWF  51
0EB8:  MOVLW  C2
0EBA:  MOVWF  50
0EBC:  MOVLW  35
0EBE:  MOVWF  4F
0EC0:  MOVLW  7D
0EC2:  MOVWF  4E
0EC4:  MOVFF  03,55
0EC8:  MOVFF  02,54
0ECC:  MOVFF  01,53
0ED0:  MOVFF  00,52
0ED4:  CALL   0462
0ED8:  MOVFF  00,10
0EDC:  MOVFF  01,11
0EE0:  MOVFF  02,12
0EE4:  MOVFF  03,13
0EE8:  CLRF   4F
0EEA:  MOVFF  05,4E
0EEE:  CALL   042C
0EF2:  MOVFF  13,4D
0EF6:  MOVFF  12,4C
0EFA:  MOVFF  11,4B
0EFE:  MOVFF  10,4A
0F02:  MOVFF  03,51
0F06:  MOVFF  02,50
0F0A:  MOVFF  01,4F
0F0E:  MOVFF  00,4E
0F12:  RCALL  0836
0F14:  MOVFF  03,0B
0F18:  MOVFF  02,0A
0F1C:  MOVFF  01,09
0F20:  MOVFF  00,08
....................       glcd_pixel(x,y,ON); 
0F24:  MOVFF  0B,4D
0F28:  MOVFF  0A,4C
0F2C:  MOVFF  09,4B
0F30:  MOVFF  08,4A
0F34:  RCALL  0990
0F36:  MOVFF  01,10
0F3A:  MOVFF  0F,4D
0F3E:  MOVFF  0E,4C
0F42:  MOVFF  0D,4B
0F46:  MOVFF  0C,4A
0F4A:  RCALL  0990
0F4C:  MOVFF  01,11
0F50:  MOVFF  10,1E
0F54:  MOVFF  01,1F
0F58:  MOVLW  01
0F5A:  MOVWF  20
0F5C:  CALL   01E4
....................    } 
0F60:  INCF   06,F
0F62:  BTFSC  FD8.2
0F64:  INCF   07,F
0F66:  BRA    0DBE
....................  
....................    while (TRUE) 
....................    { 
....................        
....................    } 
0F68:  BRA    0F68
.................... }       
....................  
....................  
0F6A:  SLEEP 

Configuration Fuses:
   Word  1: CE24   IESO FCMEN HSPLL PLL5 CPUDIV1 USBDIV
   Word  2: 1E3E   BROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 8500   NOPBADEN CCP2C1 MCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST NOICPRT
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
